#include <stdio.h>

int main() {
    char chess[8][8];
    int count = 0;
    for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 8; j++) {
            scanf("%c", &chess[i][j]);
            if (chess[i][j] == 'F') {
                if ((i == 0 || i == 2 || i == 4 || i == 6) && (j == 0 || j == 2 || j == 4 || j == 6)) {
                    count++;
                } else if ((i == 1 || i == 3 || i == 5 || i == 7) && (j == 1 || j == 3 || j == 5 || j == 7)) {
                    count++;
                }
            }
        }
        getchar(); // 이중 for문으로 인해 '\n' 버퍼가 저장되어 쓸데없는 값이 같이 계산된다.
        // 그래서 안쪽 for문이 끝나면 '\n' 입력된 버퍼를 따로 제외하기 위해.
    }
    printf("%d\n", count);
}
/*
제시된 코드에서 문제는 개행 문자(’\n’)를 처리하지 않은 것이다. 
scanf 함수를 사용하여 문자를 입력 받을 때, 
이전 입력에서 남아있는 개행 문자(’\n’)가 읽혀질 수 있다. 
따라서, 각 행의 입력이 끝난 후에 개행 문자를 처리해주어야 한다.

위 코드처럼 수정하면, 각 행의 입력이 끝난 후에 남아있는 개행 문자(’\n’)를 
제거하고 다음 행의 첫 번째 열부터 정상적으로 입력받을 수 있다.

`getchar()` 함수는 표준 입력(stdin)에서 한 문자를 읽어오는 함수입니다. 
이 함수를 사용하면 버퍼에 남아있는 문자를 하나씩 읽어올 수 있습니다.

백준 1100번 문제의 경우, 체스판의 각 행을 입력받은 후에 개행 문자('\n')가 
남게 됩니다. 이 개행 문자는 다음 `scanf("%c", &chess[i][j]);` 호출 시에 
읽혀지고, 실제로 원하는 체스판의 정보 대신 개행 문자가 `chess[i][j]`에 
저장됩니다. 따라서, 실제로 원하는 체스판 정보가 한 칸 밀리게 되며, 
이로 인해 올바르지 않은 결과를 얻게 됩니다.

이 문제를 해결하기 위해 각 행을 모두 입력받은 후에 `getchar()`를 호출하여 
버퍼에 남아있는 개행 문자('\n')를 제거합니다. 이렇게 하면 다음 행을 올바르게 
입력받을 수 있습니다.

따라서 `getchar()` 하나만 넣었을 때 제대로 작동하는 이유는, 
각 행의 입력이 끝난 후 남아있는 개행 문자('\n')를 제거함으로써 
다음 행의 첫 번째 열부터 정상적으로 입력 받기 때문입니다.
*/